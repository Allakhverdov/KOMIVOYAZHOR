#include<iostream>
#include<vector>
#include<algorithm>

struct Edge
{
    Edge(int from, int to, int weight) : from(from), to(to), weight(weight){}
    Edge(){}
    int from = 0;
    int to = 0;
    int weight = 0;
};

class Cmp
{
public:
    bool operator() (const Edge &a, const Edge &b)
    {
        return a.weight < b.weight;
    }
}cmpp;

struct ArcGraph
{
    explicit ArcGraph(size_t EdgeCount);
    ~ArcGraph() = default;
    void AddEdge(int from, int to, int weight);
    int ECount() const;
    std::vector<Edge> GetAllEdge() const;
private:
    std::vector<Edge>AllEdge;
};

ArcGraph::ArcGraph(size_t EdgeCount)
{
    AllEdge.resize(EdgeCount);
}

void ArcGraph::AddEdge(int from, int to, int weight)
{
    Edge new_edge(from, to, weight);
    AllEdge.push_back(new_edge);
}

int ArcGraph::ECount() const
{
    return AllEdge.size();
}

std::vector<Edge> ArcGraph::GetAllEdge() const
{
    return AllEdge;
}

struct Peak
{
    Peak(int parent, int me): parent(parent), me(me){}
    Peak(){}
    int parent = 0;
    int me = 0;
    int rank = 0;
};

struct DSU
{
    DSU(size_t VCount);
    void Union(int x,int y);
    void Link(int x,int y);
    int FindSet(int x);
    std::vector<Peak>Trees;
};

DSU::DSU(size_t VCount)
{
    Trees.resize(VCount);
    for(int i = 0; i < VCount; ++i)
    {
        
        Trees[i].me = i;
        Trees[i].parent = i;
        Trees[i].rank = 0;
    }
}

int DSU::FindSet(int x)
{
    if (Trees[x].me != Trees[x].parent)
    {
        Trees[x].parent = FindSet(Trees[x].parent);
    }
    return Trees[x].parent;
}

void DSU::Link(int x_root,int y_root)
{
    if(Trees[x_root].rank > Trees[y_root].rank)
    {
        Trees[y_root].parent = x_root;
    }
    else if(Trees[x_root].rank < Trees[y_root].rank)
    {
        Trees[x_root].parent = y_root;
    }
    if(Trees[x_root].rank == Trees[y_root].rank)
    {
        Trees[x_root].rank = Trees[y_root].rank + 1;
        Trees[y_root].parent = x_root;
    }
}

void DSU::Union(int x,int y)
{
    Link(FindSet(x), FindSet(y));
}

int Kruskal (ArcGraph G, int V)
{
    int answer = 0;
    DSU forest (V);
    std::vector<Edge>AllEdge = G.GetAllEdge();
    std::sort(AllEdge.begin(), AllEdge.end(), cmpp);
    for(int i = 0; i < G.ECount(); ++i)
    {
        Edge next_edge = AllEdge[i];
        if(forest.FindSet(next_edge.from) != forest.FindSet(next_edge.to))
        {
            forest.Union(next_edge.from, next_edge.to);
            answer += next_edge.weight;
        }
    }
    return answer;
}

int main()
{
    int E = 0;
    int V = 0;
    ArcGraph G(0);
    std::cin >> V >> E;
    for(int i = 0; i < E; ++i)
    {
        int from = 0;
        int to = 0;
        int weight = 0;
        std::cin >> from >> to >> weight;
        G.AddEdge(from - 1, to - 1, weight);
    }
    std::cout << Kruskal(G, V);
    return 0;
}
